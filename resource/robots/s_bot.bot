--- from quickBot v2, modified by sam686
--- works on all game modes, except this bot don't work on non-pickup soccer

goalPt = point.new(0,0)

prevtarget = nil

gotoPositionWasNil = true
 
o = point.new(0,0)
 
botLoc = nil        -- Bot's location, will be updated when onTick() is run

-- This function gets run once during setup.  It is the only time we can declare variables
-- and have them be defined as globals.
function main()
    botRadius = bot:getRad()
    pathTimerMax = 250
    pathTimer = pathTimerMax
    dirToGo = 0
    game = GameInfo()

    difficulty         = tonumber(arg[1]) or .5
    agression          = tonumber(arg[2]) or 0.5
    defense            = tonumber(arg[3]) or 0
    speed              = tonumber(arg[4]) or 1
    directionThreshold = tonumber(arg[5]) or .25

    gameType = game:getGameType()
    
    averageIndex = 1
    averageMax = 20

    averageArray = { }
    for i = 1, averageMax do
        averageArray[i] = false
    end

    myOrbitalDirection = 1
    myObjective = math.random(0, 10)
end
 

items = { }     -- Global variable, reusable container for findGlobalItems.  Reusing this table avoids costs of
                -- constructing and destructing it every time we call findGlobalItems().  Be sure to clear the
                -- table before reusing it!
function shieldSelf()
    table.clear(items)
    findItems(items, BulletType, AsteroidType, MineType)

    local distToShieldAt = botRadius * 2 + (1 - difficulty) * 100
    if (items ~= nil) then
        for i,bullet in ipairs(items) do
            local bulletLoc = bullet:getLoc()
            local bulletVel = bullet:getVel()
            local angleDiff = math.abs(angleDifference(point.angleTo(o, bulletVel), point.angleTo(bulletLoc, botLoc)))
            --logprint(angleDiff)
            if (point.distanceTo(bulletLoc, botLoc) < distToShieldAt + bullet:getRad() + point.distanceTo(o, bulletVel) * 50 and angleDiff < math.pi / 4) then
                bot:activateModule(ModuleShield)
                return(true)
            end
        end
    end
end

function angleDifference(angleA, angleB)
    return (math.mod(math.mod(angleA - angleB, math.pi * 2) + math.pi * 3, math.pi * 2) - math.pi)
end

function fireAtObjects()
    table.clear(items)
    findItems(items, RobotType, TurretType, ShipType, AsteroidType, ForceFieldProjectorType, SpyBugType, CoreType)
    for index,enemy in ipairs(items) do
        if(fireAtObject(enemy, WeaponPhaser)) then
            break
        end
    end
end
 
 
-- Fires at the specified object with the specified weapon if the obj is a good target.
-- Does not fire if object is on the same team or if there is something in the way.
-- Returns whether it fired or not.
function fireAtObject(obj, weapon)
    local classId = obj:getClassID()

    if(classId == TurretType or classId == ForceFieldProjectorType) then
     if(obj:getHealth() < .1) then
         --logprint("He's dead, Jim.")
         return(false)
        end
    end
    
    if(classId == ShipType    or   classId == RobotType   or   classId == ForceFieldProjectorType   or
        classId == TurretType  or   classId == CoreType) then
           if obj:getTeamIndx() == bot:getTeamIndx() and game:isTeamGame() or obj:getTeamIndx() == NeutralTeamIndx then
                --logprint("It's an ally.")
                return(false)
           end
   end

    
    local angle = getFiringSolution(obj)
    if angle ~= nil and bot:hasWeapon(weapon) then
        bot:setAngle(angle + math.rad((math.random()-0.5)*20*(1-difficulty)))
        bot:setWeapon(weapon)
        bot:fire()
        --logprint("bot:fire() called!");
        return(true)
    end
    --logprint("Firing solution not found.");
    return(false)
end
 
 
function getName()
     return("S_Bot")
end


function shield()
    averageArray[averageIndex] = shieldSelf()
    averageIndex = math.mod(averageIndex,averageMax) + 1

    local shieldPercent = 0

    for i = 1, averageMax do
        if(averageArray[averageIndex]) then
            shieldPercent = shieldPercent + 1
        end
    end

    shieldPercent = shieldPercent / averageMax

    if(shieldPercent > directionThreshold) then
        myOrbitalDirection = -myOrbitalDirection
        for i = 1, averageMax do
            averageArray[i] = false
        end
    end
end
 
function orbitPoint(pt, dir, inputDist, inputStrictness)
    local distAway = botRadius * 7
    local strictness = 2
    local direction = 1

    if(dir ~= nil) then 
        direction = dir 
    end


    if(inputDist ~= nil) then 
        distAway = inputDist 
    end

    if(inputStrictness ~= nil) then 
        strictness = inputStrictness 
    end

    if(pt ~= nil) then
        local dist = point.distanceTo(pt, botLoc)
        local deltaDistance = (dist - distAway) * strictness / distAway
        local sign = 1
        if(deltaDistance > 0) then
            sign = 1
        elseif(deltaDistance < 0) then
            sign = -1
        end

        local changeInAngle = (math.abs(deltaDistance)/(deltaDistance + sign)) * math.pi/2
        local angleToPoint = point.angleTo(pt, bot:getLoc())
        dirToGo = angleToPoint + (math.pi/2 + changeInAngle)*direction
        --bot:setThrust(speed, dirToGo)
    end
end

function gotoPosition(pt)
    if pt ~= nil then
        gotoPositionWasNil = false
        if pathTimer < .01 then
            goalPt = bot:getWaypoint(pt)
            if(goalPt ~= nil) then
                dirToGo = point.angleTo(botLoc, goalPt)
            end
        end
    end
end

function gotoAndOrbitPosition(pt)
    if pt ~= nil then
        gotoPositionWasNil = false
        if not bot:hasLosPt(pt) then
            gotoPositionWasNil = false
            gotoPosition(pt)
        else
            gotoPositionWasNil = false
            orbitPoint(pt, myOrbitalDirection, botRadius * 5, 2)
        end
    end
end
 
-- Returns true if it found an enemy to fight
function attackNearbyEnemies(target, agressionLevel)
    if target ~= nil then
        local targetLoc = target:getLoc()
      
        -- local dist    = point.distanceTo(botLoc, targetLoc)
        local myPow   = bot:getEnergy() + bot:getHealth()

        table.clear(items)
        findItems(items, ShipType, RobotType)
      
        local otherPow = target:getEnergy() + target:getHealth() * #items
      
        --advantage is between -1 and 1, -1 meaning an extreme disadvantage and 1 meaning an extreme advantage
        local advantage = (myPow - otherPow) / math.max(myPow, otherPow)
        if(advantage  / 2 + .5  >agressionLevel) then
            --orbitPoint(targetLoc, myOrbitalDirection, botRadius * 9, 2)
            prevtarget = targetLoc
            return(false)      -- was true
        else
        end
    end
    return(false)
end


-- Returns the objective for the bot, in the form of an object the bot can navigate towards.  This makes bots choose different defending locations.
-- If onTeam is true, will only return items on specified team.  If onTeam is false, will return items *not* on 
-- specified team.  If called with fewer than three args, will ignore team altogether.
function getObjective(objType, team, onTeam)

    table.clear(items)
    bot:findGlobalItems(items, objType)         -- Returns a list of all items of type objType in the game

    local itemsOnMyTeam = {}
    local currentIndex = 1

    for index, item in ipairs(items) do         -- Iterate through all found items
        local itemTeamIndex = item:getTeamIndx()

        if (objType == FlagType) and (gameType == NexusGame) then
            if not item:isOnShip() then
                itemsOnMyTeam[currentIndex] = item
                currentIndex = currentIndex + 1
            end
        elseif (objType == FlagType) and ((gameType == HTFGame) or (gameType == RetrieveGame)) and item:isInCaptureZone() then
                --logprint(item:getCaptureZone():getTeamIndx());
            if item:getCaptureZone():getTeamIndx() ~= bot:getTeamIndx() then
                itemsOnMyTeam[currentIndex] = item
                currentIndex = currentIndex + 1
            end
        elseif (objType == GoalZoneType) and (gameType == HTFGame or gameType == RetrieveGame) then
            if onTeam == nil or ((itemTeamIndex == team) == onTeam) then
                if not item:hasFlag() then
                    itemsOnMyTeam[currentIndex] = item
                    currentIndex = currentIndex + 1
                end
            end
        else
            if (itemTeamIndex == NeutralTeamIndx) and (objType ~= GoalZoneType or gameType ~= ZoneControlGame) then
                itemTeamIndex = team   -- anything Neutral is on our team (except zone control neutral goal zone)
            end
            if onTeam == nil or ((itemTeamIndex == team) == onTeam) then
                itemsOnMyTeam[currentIndex] = item
                currentIndex = currentIndex + 1
            end
        end
    end
    local listMax = 0
    --find max
    if itemsOnMyTeam[1] ~= nil then
        for index,item in ipairs(itemsOnMyTeam) do
            if(item ~= nil) then
                listMax = listMax + 1
            end
        end
        local targetNum = math.mod(myObjective, listMax) + 1
        return(itemsOnMyTeam[targetNum])
    else
        return(nil)
    end

--  local closestitem = 0 --itemsOnMyTeam[1]
--  local cur = 1
--  local closestdist = 99999999
--  while itemsOnMyTeam[cur] ~= nil do
--      local item1 = itemsOnMyTeam[cur]
--      if item1 ~= nil then
--          local loc = item1.getLoc()
--          if loc ~= nil then
--              local dist = point.distanceTo(botLoc, loc)
--              if dist < closestdist then
--                  closestdist = dist
--                  closesetitem = item1
--              end
--          end
--      end
--      cur=cur+1
--  end
--  return(closestitem)
end


function doObjective(closestEnemy)
    gotoPositionWasNil = true
    if(gameType == BitmatchGame) then
        --Nothing to do here.           
    elseif(gameType == NexusGame) then
        -- Grab any flags that are found, and go to nexus when it opens
        local otherFlag = getObjective(FlagType)            -- Find any flags
        if otherFlag ~= nil then gotoPosition(otherFlag:getLoc()) end
        -- logprint(bot:getFlagCount())  -- always 1
        if bot:getFlagCount() > 3 and (game:isNexusOpen() or game:getNexusTimeLeft() < 10000) then  --  Need to know if nexus is open
            local nexusOrFlag = getObjective(NexusType)  -- unimplemented push function error.
            if nexusOrFlag ~= nil then 
                gotoPosition(nexusOrFlag:getLoc()) 
            end
        end
    elseif(gameType == RabbitGame) then
        --Grab a flag, or go after the flag.            
        if not bot:hasFlag() then
            local otherFlag = getObjective(FlagType, bot:getTeamIndx(), true)       -- Find flags on our team
            gotoPosition(otherFlag:getLoc())
        end
    elseif(gameType == HTFGame or gameType == RetrieveGame) then
        -- Grab the flag and put it into goal zones
        -- Robot keeps trying to pick up the flags that is already in the goalZones
        if bot:hasFlag() then
            local otherFlag = getObjective(GoalZoneType, bot:getTeamIndx(), true)   -- Find GoalZone on our team
            if otherFlag ~= nil then 
                gotoPosition(otherFlag:getLoc()) 
            end
        else
            local otherFlag = getObjective(FlagType, bot:getTeamIndx(), true)       -- Find flags on our team
            if otherFlag ~= nil then 
                gotoPosition(otherFlag:getLoc()) 
            end
        end
    elseif(gameType == CTFGame) then
        --defend the flag
        local myFlag = getObjective(FlagType, bot:getTeamIndx(), true)              -- Find flags on our team
        local otherFlag = getObjective(FlagType, bot:getTeamIndx(), false)          -- Find flags not on our team

        if(defense < .5) then
            if bot:hasFlag() then
                if not myFlag:isOnShip() then
                    gotoPosition(myFlag:getLoc())
                else
                    gotoAndOrbitPosition(myFlag:getLoc())
                end
                --gotoPosition(myFlag:getLoc())
            elseif(otherFlag ~= nil) then
                if myFlag:isOnShip() then
                    gotoPosition(myFlag:getLoc())
                elseif not otherFlag:isOnShip() then
                    gotoPosition(otherFlag:getLoc())
                else
                    gotoAndOrbitPosition(otherFlag:getLoc())
                end
            end
        else
            if bot:hasFlag() then
                gotoPosition(myFlag:getLoc())
            elseif myFlag:isInInitLoc() then
                gotoAndOrbitPosition(myFlag:getLoc())
            else
                if myFlag:isOnShip() then
                    gotoAndOrbitPosition(myFlag:getLoc())
                else
                    gotoPosition(myFlag:getLoc())
                end
            end
        end
    elseif(gameType == SoccerGame) then
        --grab soccer and put into enemy goal
        -- How do we know if we are holding soccer ? (not supported when cannot pickup soccer (016)
        if bot:getMountedItems(SoccerBallItemType)[1] ~= nil then
            local otherFlag = getObjective(GoalZoneType, bot:getTeamIndx(), false)      -- Find GoalZones not on our team
            if otherFlag ~= nil then 
                gotoPosition(otherFlag:getLoc()) 
            end           
        else
            local otherFlag = getObjective(SoccerBallItemType)                          -- Find SoccerBall
            if otherFlag ~= nil then 
                gotoPosition(otherFlag:getLoc()) 
            end
        end
    elseif(gameType == ZoneControlGame) then
        -- Grab flag, then go after zones that is not ours.
        if not bot:hasFlag() then
            local otherFlag = getObjective(FlagType, bot:getTeamIndx(), true)           -- Find flags on our team
            if otherFlag ~= nil then
                if otherFlag:isOnShip() then
                    gotoAndOrbitPosition(otherFlag:getLoc())
                else
                    gotoPosition(otherFlag:getLoc())
                end
            end
        else
            local otherFlag = getObjective(GoalZoneType, bot:getTeamIndx(), false)      -- Find GoalZones on our team
            if otherFlag then
                gotoPosition(otherFlag:getLoc())
            end
        end

    elseif(gameType == CoreGame) then
        local obj = getObjective(CoreType, bot:getTeamIndx(), false)                    -- Find enemy Core
        if obj ~= nil then
            gotoAndOrbitPosition(obj:getLoc())
        end
    end

    -- If we have no where to go, go to nearest enemy.
    if gotoPositionWasNil then
        if(closestEnemy ~= nil) then
            prevtarget = closestEnemy:getLoc()
        end
        if(prevtarget ~= nil) then 
            gotoAndOrbitPosition(prevtarget) 
        end
    end
end
 

function goInDirection()
    bot:setThrust(speed,dirToGo)
end


-- This function gets called every game tick; deltaTime is the time that has elapsed since it was last called
function onTick(deltaTime)
    botLoc = bot:getLoc()
    pathTimer = pathTimer - deltaTime
    assert(bot:getLoc() ~= nil)

    local closestEnemy = bot:findClosestEnemy()
    
    -- attackNearbyEnemies returns true if there is an enemy to fight, false if the bot can do something else
    if not attackNearbyEnemies(closestEnemy, 1 - agression) then
        doObjective(closestEnemy)
    end

    doObjective(closestEnemy)

    goInDirection()
    fireAtObjects()
    shield()
    if(pathTimer < 0) then
        pathTimer = pathTimerMax + math.random(0, pathTimerMax)
    end
end