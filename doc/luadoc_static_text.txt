/**

@mainpage Bitfighter Lua Documentation

@section intro_sec Introduction

Here is some info about scripting levels and robots in Bitfighter.

All scripts must contain a \e main() function.  There are some subtle differences between how bots and levelgens use this function, but we can ignore those for the moment.  The important thing is the \e main() function is run when the script is loaded, and should contain any configuration code the script requires.  

It is possible to specify a list of arguments to be passed to a robot or levelgen script.  These arguments will be placed in a table called \e arg, which is the standard Lua location for storing command line parameters.

@subsection Robots
A robot's \e main() function gets run as soon as the bot is added to the game.  In the main function, the bot should subscribe to any events it wants to listen for (though it can always subscribe later).  By default, all bots are subscribed to the \e Tick event, though you can unsbscribe to that event if the bot only responds to events (\e eliza.bot works this way -- in its main function, it subscribes to the \e MsgRecieved event, and unsbscribes to \e Tick.)

@subsection Levelgens
Levelgens are a little different.  While the entire purupose of a bot is to actively participate in a game, many levelgens will not stick around after the level has been loaded. For a basic levelgen, the entire script might be contained in the main() function -- it might create some items, and do nothing more.

If a level has a levelgen script, its main function is executed as the level is loaded, after all objects defined in the level file have been created.  Therefore a levelgen can act upon those objects, either altering them, deleting them, or by adding completely new objects.

Levelgens can also subscribe to events; their event handlers will be called throughout the game as events are fired.

Unlike robots, levelgens are not automatically subscribed to the \e Tick event.


@subsection Editor Plugins
Plugins run once when called, then exit.  The \e main() function is called.

Since plugins do not linger after being called, they cannot subscribe to or respond to events.

***** Need to describe the menu building system here, and how those args get passed to main(). *****


@section datatypes Bitfighter datatypes
* point - Point is a low-overhead custom structure that represents an xy coordinate pair.  See the \link point point class documentation \endlink for further details.

Note that points are immutable, so cannot be changed once created.


* geometry - Geometry is not a formal datatype, but rather a reference to either to a point or a table of points, depending on the context. 
For example, if the object is inherently point-like (such as an Item or Projectile), then geometry is a Point.  
For more complex objects (such as a WallItem or a Zone), geometry refers to a Lua table of points.
Some objects have a specific number of points.  A TextItem, for example, consists of exactly two points, defining its
start and endpoints.  Some items (like Zones and \link PolyWall PolyWalls \endlink) must have a minimum of three points.  See the documentation for individual items for details.

The Geom class provides a collection of tools to make common transormations to a point or a table of points. 

* Other datatypes

bool - Either \e true or \e false.  In Lua, both nil and false make a condition false; any other value makes it true.

int - A number that has no decimal component.  Unlike some languages, Lua does not distinguish between integers and floating point numbers -- they are both stored internally as numbers.  When a function requires an integer argument, and you provide a floating point number, the fraction will be silently dropped.

*num - A real (double-precision floating-point) number.  You can also specify an integer without any problems.

@subsection step1 Step 1: Opening the box

@section programming_robots Programming Robots

When the bot is first started, Bitfighter will call the bot's getName() function.  This function should return a string which will be used as the bot's name.  If the function is not implemented, or returns a nil, the bot will be assigned a name.  If getName() returns any other value, an error will be logged, and the script will be terminated.  Once the bot's name has been specified, it cannot be changed.

A very simple getName() function might look like this:
\code
function getName()
     return("Asimov")
end
\endcode


@section programming_levelgens Programming Levelgens

@section programming_plugins Programming Editor Plugins

Editor plugins can be used to extend the functionality of the editor, and to add new or experimental geometry manipulation functions.

When the user runs a plugin, the editor first tries to call a function called \e getArgsMenu().  If this function exists, it must
return a table containing the menu name and the various items to be displayed on it.  The values that the user enters for these
items will be passed to the script in the arg table, Lua's structure for passing command line arguments to a script.  If \e getArgsMenu()
does not exist, the plugin will be run with no arguments.

Unlike levelgen and bot scripts, plugins do not respond to events, and often consist of only a \e main() function, and, if they require 
special inputs, a \e getArgsMenu() function.

The following is the getArgsMenu() function from the draw_arcs plugin, which can be found in Bitfighter's \e editor_plugins folder. 
\code
function getArgsMenu()
   
   return "Create Arc",         -- Title shown on menu
      {
         CounterMenuItem.new("Angle",          90, 1,       0,   360, "deg.",       "", "Sweep of arc"),    
         CounterMenuItem.new("Precision",      16, 1,       4,    62, "divisions",  "", "Number of sections per arc"),
         CounterMenuItem.new("Radius of arc", 100, 1,       1,   500, "grid units", "", "Radius of the arc"),
         CounterMenuItem.new("Start of arc",   90, 1,       0,   360, "degrees",    "", "Start angle of arc from the positive x axis"),

         ToggleMenuItem.new ("Type", { "BarrierMaker", "LoadoutZone", "GoalZone" }, 1, true, "Type of item to insert"),
         
         CounterMenuItem.new("Barrier Width",  50, 1,       1,    50, "grid units", "", "Width of wall if BarrierMaker is selected above"),
         CounterMenuItem.new("Center X",        0, 10, -10000, 10000, "",           "", "X coordinate of center of arc"),
         CounterMenuItem.new("Center Y",        0, 10, -10000, 10000, "",           "", "Y coordinate of center of arc")
      }
end
\endcode

@section events Events

Robots and Levelgens can register to be notified of certain game events.  When the event occurs, a special function in the script is called, which can do anything from 
add an item to the game (in the case of Levelgens) to changing destinations (for Robots).  Editor plugins cannot subscribe to events.

@section timers Timers
Timer is a utility class that makes it easier to manage timing periodic or delayed events.  The timer code is based on a very nice library written by Haywood Slap.

A timer object that can be used to schedule arbitrary events to be executed at some time in the future.  All times are given in milliseconds.

See the Timer class for more details.


@section debugging Debugging Tips

Any of your scripts can print a stack trace to see how you got to a particular execution point.  This can be very helpful if there are several conditions under which a function can be called.  

The logprint command will print messages both to the Bitfighter logfile, as well as to the in-game console (which you can turn on with ctrl+/).

Finally, if you detect an unexpected error condition, you can log a message, trigger a stack trace, and terminate the script with Lua's error function.

\code
logprint("Here's a log message:")
logprint(debug.traceback())

if target == nil then error("Have a nil target!") end
\endcode



@page page1 A documentation page
  \tableofcontents
  Leading text.
  \section sec An example section
  This page contains the subsections \ref subsection1 and \ref subsection2.
  For more info see page \ref page2.
  \subsection subsection1 The first subsection
  Text.
  \subsection subsection2 The second subsection
  More text.

@page page2 Another page
  Even more info.



 */